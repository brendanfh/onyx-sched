//+optional-semicolons

package sched

use core.thread
use core.os
use core.io
use core.iter
use core.math
use core.sync
use core.array
use core.heap
use runtime
use core.intrinsics.atomics {__atomic_store}

Scheduler :: struct {
    _tasks: Lock(heap.Heap(Task))

    _next_id: u64

    _executer: thread.Thread
    _running: bool

    _wakeup_flag: u32
}

Task :: struct {
    id: u64

    when: i64 // UNIX Time in milliseconds

    func: (rawptr) -> void
    arg: rawptr
}

scheduler_func :: struct { name: str }


#inject Scheduler {
    make :: () -> (out: Scheduler) {
        out._tasks = Lock.make(
            heap.make(Task, (x, y) => cast(i32)(x.when - y.when))
        )
        return
    }

    start :: (self: &Scheduler) {
        if self._running do return

        thread.spawn(&self._executer, self, scheduler_thread)
        self._running = true
    }

    join :: (self: &Scheduler) {
        thread.join(&self._executer)
    }

    run :: (self: &Scheduler) {
        self->start()
        self->join()
    }

    schedule_at :: (self: &Scheduler, at: u64, func: (&T) -> void, arg: &$T) -> u64 {
        id := self._next_id
        self._next_id += 1

        self._tasks->with([tasks] {
            heap.insert(tasks, Task.{
                id, at, func, arg
            })
        })

        if self._running {
            self._wakeup_flag = 1
            runtime.platform.__futex_wake(&self._wakeup_flag, 1)
        }

        return id
    }

    schedule_in :: (self: &Scheduler, in_: u64, func: (&T) -> void, arg: &$T) -> u64 {
        id := self._next_id
        self._next_id += 1

        self._tasks->with([tasks] {
            heap.insert(tasks, Task.{
                id, in_ + os.time(), func, arg
            })
        })

        if self._running {
            self._wakeup_flag = 1
            runtime.platform.__futex_wake(&self._wakeup_flag, 1)
        }

        return id
    }

    cancel :: (self: &Scheduler, id: u64) {
    }
}

#local
scheduler_thread :: (scheduler: &Scheduler) {
    while true {
        now: i64 = os.time()
        next: i64 = now + 30000

        scheduler._tasks->with([tasks] {
            while tasks.data[0].when <= now && tasks.data.count > 0 {
                t := heap.remove_top(tasks)

                t.func(t.arg)
            }

            if tasks.data.count > 0 {
                next = tasks.data[0].when
            }
        })

        to_sleep := math.min(next - now, 30000)

        runtime.platform.__futex_wait(&scheduler._wakeup_flag, 0, ~~to_sleep)
        scheduler._wakeup_flag = 0
    }
}

#local
worker_thread :: (scheduler: &Scheduler) {
    while scheduler._running {

    }
}


Lock :: struct (T: type_expr) {
    mutex: sync.Mutex
    value: T
}

#inject Lock {
    make :: (v: $T) => Lock(T).{
        value = v
    }

    with :: macro (l: &Lock, body: Code) -> u32 {
        sync.scoped_mutex(&l.mutex)

        #unquote body(&l.value)
       
        return 0
    }
}


