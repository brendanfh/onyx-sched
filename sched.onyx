//+optional-semicolons

package sched

use core.thread
use core.os
use core.io
use core.iter
use core.math
use core.sync
use core.array
use runtime
use core.intrinsics.atomics {__atomic_store}

Scheduler :: struct {
    _tasks: Lock([..] Task)

    _next_id: u64

    _executer: thread.Thread
    _running: bool

    _wakeup_flag: u32
}

Task :: struct {
    id: u64

    when: i64 // UNIX Time in milliseconds

    func: (rawptr) -> void
    arg: rawptr
}

scheduler_func :: struct { name: str }


#inject Scheduler {
    make :: () -> (out: Scheduler) {
        out._tasks = Lock.make(make([..] Task))
        return
    }

    start :: (self: &Scheduler) {
        if self._running do return

        thread.spawn(&self._executer, self, scheduler_thread)
        self._running = true
    }

    join :: (self: &Scheduler) {
        thread.join(&self._executer)
    }

    run :: (self: &Scheduler) {
        self->start()
        self->join()
    }

    schedule_at :: (self: &Scheduler, at: u64, func: (&T) -> void, arg: &$T) -> u64 {
        id := self._next_id
        self._next_id += 1

        self._tasks->with([tasks] {
            array.push(tasks, Task.{
                id, at, func, arg
            })
        })

        __atomic_store(&self._wakeup_flag, 0)
        runtime.platform.__futex_wake(&self._wakeup_flag, 1)

        return id
    }

    schedule_in :: (self: &Scheduler, in_: u64, func: (&T) -> void, arg: &$T) -> u64 {
        id := self._next_id
        self._next_id += 1

        self._tasks->with([tasks] {
            array.push(tasks, Task.{
                id, in_ + os.time(), func, arg
            })
        })

        __atomic_store(&self._wakeup_flag, 0)
        runtime.platform.__futex_wake(&self._wakeup_flag, 1)

        return id
    }

    cancel :: (self: &Scheduler, id: u64) {
        self._tasks->with([tasks] {
            array.filter(tasks, [t](t.id != id))
        })
    }
}

#local
scheduler_thread :: (scheduler: &Scheduler) {
    while true {
        now: i64 = os.time()
        next: i64 = now + 30000

        scheduler._tasks->with([tasks] {
            for t in iter.as_iter(tasks) {
                if t.when > now do continue

                t.func(t.arg)
                #remove // and mark as done
            }

            next = iter.as_iter(*tasks)
                ->map(x => x.when)
                ->fold1((x, y) => math.min(x, y))
                ->value_or(next)
        })

        to_sleep := math.min(next - now, 30000)

        while runtime.platform.__futex_wait(&scheduler._wakeup_flag, 1, ~~to_sleep) == 2 {
            __atomic_store(&scheduler._wakeup_flag, 1);
        }
    }
}

#local
worker_thread :: (scheduler: &Scheduler) {
    while scheduler._running {

    }
}


Lock :: struct (T: type_expr) {
    mutex: sync.Mutex
    value: T
}

#inject Lock {
    make :: (v: $T) => Lock(T).{
        value = v
    }

    with :: macro (l: &Lock, body: Code) -> u32 {
        sync.scoped_mutex(&l.mutex)

        #unquote body(&l.value)
       
        return 0
    }
}


